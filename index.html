<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Advice Board</title>
  <script type="module">
    // Import Firebase modules
    import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { getFirestore, collection, doc, addDoc, setDoc, deleteDoc, getDoc, getDocs, serverTimestamp, 
            query, where, orderBy, onSnapshot, limit, startAfter } 
      from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
    // import { db } from "./firebase";

  const firebaseConfig = {
    apiKey: "AIzaSyC8i6009Q7MF8jKBk88-akVRUVhhuBVHSU",
    authDomain: "advice-ad042.firebaseapp.com",
    projectId: "advice-ad042",
    storageBucket: "advice-ad042.firebasestorage.app",
    messagingSenderId: "677646026777",
    appId: "1:677646026777:web:8dd79e190d4d273b9fc288",
    measurementId: "G-1BKY784SFB"
  };

  // Initialize Firebase
  let app;
  try {
    app = getApp();
  } catch (e) {
    app = initializeApp(firebaseConfig);
  }
  const db = getFirestore(app);
  const auth = getAuth(app);
  const adviceList = document.getElementById('advice-list');
  const form = document.getElementById('advice-form');
  const loginSection = document.getElementById("login-section");
  const loggedInSection = document.getElementById("logged-in-section");
  const userInfo = document.getElementById("user-info");
  const logoutBtn = document.getElementById("logout-btn");
  const addAdviceSection = document.getElementById("add-advice-section");
  const filters = document.getElementById("filters");
  let unsubscribe = null;
  let lastVisible = null;
  let filteredDocs = [];
  let currentPage = 0;
  const PAGE_SIZE = 10;
  let currentQuery = null;
  let currentUser = null;

const categorySelect = document.getElementById("category-select");
const filterMy = document.getElementById("filter-my");
const filterBookmarked = document.getElementById("filter-bookmarked");
categorySelect.addEventListener("change", () => {
  const selectedCategory = categorySelect.value;
});
[filterMy, filterBookmarked, categorySelect].forEach(el => {
  el.addEventListener("change", () => {
    applyFilters();
  });
});

// üß† Load advice (filtered or not)
async function loadAdvice(user, viewMode = "all", category = null) {
  if (unsubscribe) unsubscribe(); // stop previous listener

  let q;
  if (viewMode === "my" && user) {
    q = query(
      collection(db, "advice"),
      where("authorId", "==", user.uid),
      orderBy("timestamp", "desc")
    );
  } else if (viewMode === "bookmarked" && user) {
    // Load bookmarked advice IDs
    const bookmarksRef = collection(db, "users", user.uid, "bookmarks");
    const bookmarkSnap = await getDocs(bookmarksRef);
    const bookmarkedIds = bookmarkSnap.docs.map((d) => d.id);

    if (bookmarkedIds.length === 0) {
      adviceList.innerHTML = "<p>No bookmarked advice yet.</p>";
      return;
    }

    // Firestore can only handle up to 10 items in an 'in' query
    const chunks = [];
    for (let i = 0; i < bookmarkedIds.length; i += 10) {
      chunks.push(bookmarkedIds.slice(i, i + 10));
    }

    adviceList.innerHTML = "";
    chunks.forEach((chunk) => {
      const qChunk = query(
        collection(db, "advice"),
        where("__name__", "in", chunk),
        orderBy("timestamp", "desc")
      );
      onSnapshot(qChunk, (snapshot) => renderAdvice(snapshot, user));
    });
    return;
  } else if (viewMode === "category" && category) {
    q = query(
      collection(db, "advice"),
      where("category", "==", category),
      orderBy("timestamp", "desc")
    );
  } else {
    q = query(collection(db, "advice"), orderBy("timestamp", "desc"));
  }

  q = query(q, limit(10)); // limit to 10 per load
  unsubscribe = onSnapshot(q, (snapshot) => {
    renderAdvice(snapshot, user);
    if (snapshot.docs.length > 0) {
      lastVisible = snapshot.docs[snapshot.docs.length - 1];
      currentQuery = q;
    }
  });
}

// üß± Render advice list
async function renderAdvice(snapshot, user) {
  adviceList.innerHTML = "";
  if (snapshot.empty) {
    adviceList.innerHTML = "<p>No advice found.</p>";
    return;
  }

  for (const docSnap of snapshot.docs) {
    const data = docSnap.data();
    const adviceId = docSnap.id;
    const isMine = user && data.authorId === user.uid;
    let isBookmarked = false;

    if (user) {
      const bookmarkRef = doc(db, "users", user.uid, "bookmarks", adviceId);
      const bookmarkSnap = await getDoc(bookmarkRef);
      isBookmarked = bookmarkSnap.exists();
    }

    const item = document.createElement("div");
    item.classList.add("advice-item");
    item.innerHTML = `
      <h3>${data.title}</h3>
      <p>${data.content}</p>
      <p><em>‚Äì ${data.author || "Anonymous"}</em></p>
      ${isMine ? "<p style='color: green; font-weight: bold;'>(Your advice)</p>" : ""}
      <button class="bookmark-btn" data-id="${adviceId}">
        ${isBookmarked ? "‚≠ê Bookmarked" : "‚òÜ Bookmark"}
      </button>
      <button class="delete-btn" data-id="${adviceId}">üóëÔ∏è Delete</button>
      <div class="feedback-section" data-advice-id="${adviceId}">
        <div class="stars"></div>
        <textarea class="comment-input" placeholder="Leave a comment..."></textarea>
        <button class="save-feedback-btn">Save</button>
        <div class="avg-rating"></div>
        <div class="comments-list"></div>
      </div>
      <hr>
    `;
    adviceList.appendChild(item);
    const feedbackSection = item.querySelector(".feedback-section");
    const starsContainer = feedbackSection.querySelector(".stars");
    createStarElements(starsContainer);
    attachStarListeners(starsContainer, adviceId, user?.uid, user?.displayName || "Anonymous");
    showFeedback(adviceId, feedbackSection);
  }

  // Attach listeners to all bookmark buttons
  document.querySelectorAll(".bookmark-btn").forEach((btn) => {
    btn.addEventListener("click", () => toggleBookmark(user, btn.dataset.id, btn));
  });

  // Attach listeners to all delete buttons
  document.querySelectorAll(".delete-btn").forEach((btn) => {
    btn.addEventListener("click", async () => {
      if (!user) {
        alert("You must be logged in to delete advice.");
        return;
      }

      const adviceId = btn.dataset.id;
      if (!confirm("Are you sure you want to delete this advice?")) return;

      try {
        await deleteDoc(doc(db, "advice", adviceId));
        alert("Advice deleted!");
        loadAdvice(user); // refresh list
      } catch (err) {
        console.error("Error deleting advice:", err);
        alert("Error deleting advice. See console for details.");
      }
    });
  });
  const loadMoreBtn = document.getElementById("load-more-btn");
  if (loadMoreBtn) {
    loadMoreBtn.style.display =
      snapshot.docs.length === 10 ? "inline-block" : "none";
  }
}

async function renderAdviceFromDocs(docArray) {
  adviceList.innerHTML = "";
  if (!docArray.length) {
    adviceList.innerHTML = "<p>No advice found.</p>";
    return;
  }

  for (const docSnap of docArray) {
    const data = docSnap.data();
    const adviceId = docSnap.id;
    const item = document.createElement("div");
    item.classList.add("advice-item");
    item.innerHTML = `
      <h3>${data.title}</h3>
      <p>${data.content}</p>
      <p><em>‚Äì ${data.author || "Anonymous"}</em></p>
      <button class="bookmark-btn" data-id="${adviceId}">‚òÜ Bookmark</button>
      <button class="delete-btn" data-id="${adviceId}">üóëÔ∏è Delete</button>
      <div class="feedback-section" data-advice-id="${adviceId}">
        <div class="stars"></div>
        <textarea class="comment-input" placeholder="Leave a comment..."></textarea>
        <button class="save-feedback-btn">Save</button>
        <div class="avg-rating"></div>
        <div class="comments-list"></div>
      </div>
      <hr>
    `;
    adviceList.appendChild(item);
    const feedbackSection = item.querySelector(".feedback-section");
    const starsContainer = feedbackSection.querySelector(".stars");
    createStarElements(starsContainer);
    attachStarListeners(starsContainer, adviceId, currentUser?.uid, currentUser?.displayName || "Anonymous");
    showFeedback(adviceId, feedbackSection);
  }

  // attach listeners to bookmark & delete buttons again
  document.querySelectorAll(".bookmark-btn").forEach((btn) => {
    btn.addEventListener("click", () => toggleBookmark(currentUser, btn.dataset.id, btn));
  });
  document.querySelectorAll(".delete-btn").forEach((btn) => {
    btn.addEventListener("click", async () => {
      if (confirm("Are you sure you want to delete this advice?")) {
        await deleteDoc(doc(db, "advice", btn.dataset.id));
        applyFilters(); // refresh list
      }
    });
  });
}

// ü™Ñ Toggle bookmark
async function toggleBookmark(user, adviceId, btn) {
  const bookmarkRef = doc(db, "users", user.uid, "bookmarks", adviceId);
  const snap = await getDoc(bookmarkRef);

  if (snap.exists()) {
    await deleteDoc(bookmarkRef);
    btn.textContent = "‚òÜ Bookmark";
  } else {
    await setDoc(bookmarkRef, { addedAt: new Date() });
    btn.textContent = "‚≠ê Bookmarked";
  }
}

async function loadCategories() {
  const categorySelect = document.getElementById("category-select");
  const adviceRef = collection(db, "advice");

  try {
    const snapshot = await getDocs(adviceRef);
    const categories = new Set();

    snapshot.forEach(doc => {
      const data = doc.data();
      if (data.category && data.category.trim() !== "") {
        categories.add(data.category.trim());
      }
    });

    // Clear existing (except "All Categories")
    categorySelect.innerHTML = '<option value="">All Categories</option>';

    // Add each category alphabetically
    Array.from(categories)
      .sort((a, b) => a.localeCompare(b))
      .forEach(cat => {
        const option = document.createElement("option");
        option.value = cat;
        option.textContent = cat;
        categorySelect.appendChild(option);
      });

  } catch (e) {
    console.error("Error loading categories:", e);
  }
}

async function saveFeedback(adviceId, userId, rating, comment, userName) {
  const feedbackRef = doc(db, "advice", adviceId, "feedback", userId);
  const data = {
    userId,
    userName,
    timestamp: serverTimestamp()
  };
  if (rating !== null && rating !== undefined) data.rating = rating;
  if (comment) data.comment = comment;

  await setDoc(feedbackRef, data, { merge: true });
}


async function loadFeedback(adviceId) {
  const feedbackCol = collection(db, "advice", adviceId, "feedback");
  const snapshot = await getDocs(feedbackCol);
  return snapshot.docs.map(doc => doc.data());
}

function calculateAverageRating(feedbackList) {
  const ratings = feedbackList
    .map(f => f.rating)
    .filter(r => typeof r === 'number');
  if (!ratings.length) return 0;
  return ratings.reduce((a,b) => a+b, 0) / ratings.length;
}

function createStarElements(container, currentRating = 0) {
  container.innerHTML = "";
  for (let i = 1; i <= 10; i++) {
    const star = document.createElement("span");
    star.classList.add("star");
    star.textContent = "‚òÖ";
    if (i <= currentRating) star.classList.add("selected");
    star.dataset.value = i;
    container.appendChild(star);
  }
}

function attachStarListeners(container, adviceId, userId, userName) {
  container.querySelectorAll(".star").forEach(star => {
    star.addEventListener("click", async () => {
      const rating = parseInt(star.dataset.value);
      
      // Update the visual state immediately
      updateStars(container, rating);
      
      // Save to Firestore (non-blocking UI)
      const comment = container.closest(".feedback-section").querySelector(".comment-input").value.trim();
      try {
        await saveFeedback(adviceId, userId, rating, comment, userName);
        console.log(`Saved rating ${rating} for ${adviceId}`);
      } catch (err) {
        console.error("Error saving feedback:", err);
      }
    });
  });
}

function updateStars(container, rating) {
  const stars = container.querySelectorAll(".star");
  stars.forEach(star => {
    const value = parseInt(star.dataset.value);
    star.classList.toggle("selected", value <= rating);
  });
}

async function showFeedback(adviceId, container) {
  const feedbackList = await loadFeedback(adviceId);
  
  if (!feedbackList.length) {
    container.querySelector(".avg-rating").textContent = "No ratings yet";
    return;
  }

  // Show average
  const ratings = feedbackList.filter(f => typeof f.rating === "number").map(f => f.rating);
  const avg = ratings.length ? (ratings.reduce((a,b)=>a+b,0)/ratings.length).toFixed(1) : "‚Äì";
  container.querySelector(".avg-rating").textContent = `Average: ${avg}`;

  // Show comments
  const commentsDiv = container.querySelector(".comments-list");
  commentsDiv.innerHTML = feedbackList
    .filter(f => f.comment)
    .map(f => `<p><strong>${f.userName || "Anon"}:</strong> ${f.comment}</p>`)
    .join("");

  // Show user's rating (if logged in)
  const userFeedback = feedbackList.find(f => f.userId === currentUser?.uid);
  if (userFeedback?.rating) {
    updateStars(container.querySelector(".stars"), userFeedback.rating);
  }
}

async function applyFilters() {
  if (!currentUser) {
    adviceList.innerHTML = "<p>Please log in to view advice.</p>";
    return;
  }

  const showMine = filterMy.checked;
  const showBookmarked = filterBookmarked.checked;
  const category = categorySelect.value;

  // Load all advice first
  const adviceRef = collection(db, "advice");
  const allSnap = await getDocs(adviceRef);
  let adviceDocs = allSnap.docs;

  // Apply "Added By Me" filter
  if (showMine) {
    adviceDocs = adviceDocs.filter(d => d.data().authorId === currentUser.uid);
  }

  // Apply "Bookmarked" filter
  if (showBookmarked) {
    const bookmarksRef = collection(db, "users", currentUser.uid, "bookmarks");
    const bookmarkSnap = await getDocs(bookmarksRef);
    const bookmarkedIds = bookmarkSnap.docs.map(b => b.id);
    adviceDocs = adviceDocs.filter(d => bookmarkedIds.includes(d.id));
  }

  // Apply category filter
  if (category) {
    adviceDocs = adviceDocs.filter(d => d.data().category === category);
  }

  filteredDocs = adviceDocs; // store all matching docs
  currentPage = 0;
  renderPaginatedAdvice();

}

function renderPaginatedAdvice() {
  const start = currentPage * PAGE_SIZE;
  const end = start + PAGE_SIZE;
  const docsToShow = filteredDocs.slice(start, end);

  renderAdviceFromDocs(docsToShow);

  const loadMoreBtn = document.getElementById("load-more-btn");
  if (filteredDocs.length > end) {
    loadMoreBtn.style.display = "inline-block";
  } else {
    loadMoreBtn.style.display = "none";
  }
}

function loadMoreAdvice() {
  if (!filteredDocs.length) return;

  currentPage++;
  renderPaginatedAdvice();
}

// üë• Handle auth state
onAuthStateChanged(auth, (user) => {
    currentUser = user;
  if (user) {
    // User is logged in
    loginSection.style.display = "none";
    loggedInSection.style.display = "block";
    addAdviceSection.style.display = "block";
    filters.classList.remove("hidden");
    loadAdvice(user);
  } else {
    // User is logged out
    loginSection.style.display = "block";
    loggedInSection.style.display = "none";
    addAdviceSection.style.display = "none";
    filters.classList.add("hidden");
    adviceList.innerHTML = "<p>Please log in to view advice.</p>";
  }
});

  // ‚úèÔ∏è Add new advice
  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    const title = document.getElementById('title').value.trim();
    const content = document.getElementById('content').value.trim();
    const author = document.getElementById('author').value.trim();
    const category = document.getElementById('category').value.trim();

    if (!title || !content) {
      alert("Title and content are required.");
      return;
    }

    try {
      await addDoc(collection(db, "advice"), {
        title,
        content,
        author: author || (currentUser ? currentUser.email : null),
        authorId: currentUser ? currentUser.uid : null,
        category: category || "Uncategorized",
        timestamp: serverTimestamp()
      });
      alert("Advice added!");
      form.reset();
      loadAdvice(); // refresh the list
    } catch (e) {
      console.error("Error adding advice:", e);
      alert("Error adding advice. See console for details.");
    }
  });

window.addEventListener("DOMContentLoaded", () => {
  loadCategories();
  applyFilters();
});

// Handle manual comment saving
document.addEventListener('click', async (e) => {
  if (e.target.classList.contains('save-feedback-btn')) {
    const section = e.target.closest('.feedback-section');
    const adviceId = section.dataset.adviceId;
    const commentInput = section.querySelector('.comment-input');
    const comment = commentInput.value.trim();
    const userId = currentUser?.uid;
    const userName = currentUser?.displayName || currentUser?.email || "Anonymous";

    if (!userId) {
      alert("Please log in to leave a comment.");
      return;
    }
    if (!comment) {
      alert("Please write a comment first!");
      return;
    }

    try {
      // Save comment (without changing rating)
      await saveFeedback(adviceId, userId, null, comment, userName);
      commentInput.value = "";
      showFeedback(adviceId, section); // refresh immediately
    } catch (err) {
      console.error("Error saving comment:", err);
    }
  }
});
// -------------------------------------------------
//  COLLAPSE / EXPAND ADD-ADVICE PANEL
// -------------------------------------------------
const toggleBtn   = document.getElementById('toggle-add-advice');
const panel       = document.getElementById('add-advice-section');

toggleBtn.addEventListener('click', () => {
  const isOpen = panel.classList.toggle('open');
  toggleBtn.setAttribute('aria-expanded', isOpen);
});

document.getElementById("load-more-btn").addEventListener("click", loadMoreAdvice);

</script>
<script type="module" src="app.js"></script>
  <style>
 form {
  background: white;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  margin-bottom: 30px;
}

input, textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 14px;
}

button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

button:hover {
  background-color: #0056b3;
}

body {
      font-family: system-ui, sans-serif;
      /* max-width: 700px; */
      margin: 40px auto;
      padding: 0 20px;
      background: #fafafa;
    }
    h1 { text-align: center; }
    .advice-item {
      background: white;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    h2 {
      margin: 0 0 8px;
    }
    p { margin: 6px 0; }
    #toggle-view {
      background-color: #6c757d;
      color: white;
      border: none;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }
    #toggle-view:hover {
      background-color: #5a6268;
    }
    .bookmark-btn {
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      color: #ff9800;
      margin-top: 6px;
    }
    .bookmark-btn:hover {
      transform: scale(1.05);
    }
    #add-advice-section {
      display: none;
    }

    .view-btn {
  padding: 8px 16px;
  margin-right: 8px;
  border: 1px solid #ccc;
  border-radius: 6px;
  background-color: #f4f4f4;
  color: #333;
  cursor: pointer;
  transition: background-color 0.2s, color 0.2s, border-color 0.2s;
}

.view-btn:hover:not(:disabled) {
  background-color: #e4e4e4;
}

.view-btn:disabled {
  opacity: 1; /* keep readable */
  cursor: not-allowed;
}

/* Selected (active) state */
#view-buttons .view-btn.selected,
#view-buttons .view-btn.selected:disabled {
  background-color: #cce5ff !important; /* light blue background */
  color: #004085 !important;            /* dark blue text */
  border-color: #66b0ff !important;     /* slightly brighter border */
  font-weight: 600;
}

#category-select {
  padding: 8px 16px;
  border: 1px solid #ccc;
  border-radius: 6px;
  background-color: #f4f4f4;
  cursor: pointer;
}

#category-select:hover {
  background-color: #e4e4e4;
}

.star {
  font-size: 20px;
  color: gray;
  cursor: pointer;
}
.star.selected {
  color: gold;
}
.feedback-section {
  margin-top: 8px;
}
.comment-input {
  display: block;
  width: 100%;
  margin-top: 4px;
  padding: 4px;
}

.delete-btn {
  background: none;
  border: none;
  color: #e74c3c;
  cursor: pointer;
  margin-left: 8px;
  font-size: 14px;
}
.delete-btn:hover {
  transform: scale(1.05);
  color: #c0392b;
}

#filters {
  display: flex;
  align-items: center;
  gap: 16px; /* space between filters */
  margin-bottom: 16px;
  flex-wrap: wrap; /* so it wraps gracefully on small screens */
}

#filters input[type="checkbox"] {
  margin-right: 6px;
}

#filters label,
#filters select {
  font-size: 14px;
}

.hidden {
  display: none !important;
}

#content-wrapper {
  display: flex;
  height: 60vh; /* Adjust this value (e.g., 70vh or 500px) based on your page's header height and testing. This limits the container so columns can scroll independently. */
  border: 1px solid #ccc; /* Optional: Adds a subtle border around the whole container for visual separation. */
  border-radius: 10px;
  overflow: hidden; /* Prevents any overflow from spilling outside the container. */
  background: #fff; /* Matches your existing advice-item background for consistency. */
  box-shadow: 0 2px 6px rgba(0,0,0,0.1); /* Matches your existing shadow for consistency. */
}

#sidebar {
  width: 250px; /* Fixed width for the sidebar. Adjust if needed (e.g., 20% for responsiveness). */
  overflow-y: auto; /* Enables vertical scrolling if filters grow long. */
  padding: 15px;
  background: #f0f0f0; /* Light gray background to distinguish the sidebar. */
  border-right: 1px solid #ccc; /* Separator line between sidebar and main content. */
  box-sizing: border-box; /* Ensures padding doesn't add to width. */
}

#main-content {
  flex: 1; /* Takes up the remaining space. */
  overflow-y: auto; /* Enables vertical scrolling for the advice list. */
  padding: 15px;
  box-sizing: border-box; /* Ensures padding doesn't add to width. */
}

/* Optional: Make the layout responsive on smaller screens (e.g., mobile) */
@media (max-width: 768px) {
  #content-wrapper {
    flex-direction: column; /* Stack sidebar on top of main content on small screens. */
    height: auto; /* Remove fixed height so it flows naturally. */
  }
  #sidebar {
    width: 100%; /* Full width on mobile. */
    border-right: none;
    border-bottom: 1px solid #ccc;
  }
}
/* -------------------------------------------------
   COLLAPSIBLE ADD-ADVICE PANEL
   ------------------------------------------------- */
#add-advice-wrapper {
  margin: 20px 0;
  background: #fff;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  overflow: hidden;               /* hide the sliding content */
}

#toggle-add-advice {
  width: 100%;
  background: #007bff;
  color: #fff;
  border: none;
  padding: 12px 20px;
  font-size: 16px;
  text-align: left;
  cursor: pointer;
  border-radius: 10px 10px 0 0;    /* rounded only on top when closed */
  transition: background 0.2s;
}
#toggle-add-advice:hover { background: #0056b3; }
#toggle-add-advice::after {
  content: "Down Arrow";
  float: right;
  font-size: 14px;
}

#add-advice-section {
  max-height: 0;                  /* closed state */
  overflow: hidden;
  transition: max-height 0.35s ease, padding 0.35s ease;
  padding: 0 20px;                /* will grow when open */
  background: #fff;
}
#add-advice-section.open {
  max-height: 800px;              /* any value larger than the form height */
  padding: 20px;                  /* normal padding when open */
}

/* make the toggle button show the correct arrow */
#toggle-add-advice[aria-expanded="true"]::after { content: "Up Arrow"; }

  </style>
</head>
<body>
  <h1>Advice Board</h1>

<!-- LOGIN FORM (shown when logged out) -->
<div id="login-section">
  <input type="email" id="email" placeholder="Email">
  <input type="password" id="password" placeholder="Password">
  <button id="login">Log In</button>
  <button id="signup">Sign Up</button>
</div>

<!-- LOGGED-IN CONTROLS -->
<div id="logged-in-section" style="display:none;">
  <p id="status"></p>
  <button id="logout">Log Out</button>
</div>

<!-- ==== COLLAPSIBLE ADD-ADVICE PANEL ==== -->
<div id="add-advice-wrapper">
  <button id="toggle-add-advice" class="toggle-btn">
    Add Advice
  </button>

  <div id="add-advice-section" class="collapse">
    <h2>Add New Advice</h2>
    <form id="advice-form">
      <label>
        Title:<br>
        <input type="text" id="title" required>
      </label><br><br>

      <label>
        Content:<br>
        <textarea id="content" rows="4" required></textarea>
      </label><br><br>

      <label>
        Author (optional):<br>
        <input type="text" id="author">
      </label><br><br>

      <label>
        Category:<br>
        <input type="text" id="category">
      </label><br><br>

      <button type="submit">Add Advice</button>
    </form>
  </div>
</div>
<hr>

<div id="content-wrapper">
  <div id="sidebar">
    <h2>Filters</h2> <!-- Optional: Adds a heading to the sidebar for clarity -->
    <div id="filters">
      <label><input type="checkbox" id="filter-my"> Added By Me</label>
      <label><input type="checkbox" id="filter-bookmarked"> Bookmarked</label>
      <label>Category:
        <select id="category-select" class="view-btn">
          <option value="">All Categories</option>
        </select>
      </label>
    </div>
  </div>
  <div id="main-content">
    <h2>Advice Board</h2>
    <div id="advice-list"></div>
    <div style="text-align:center; margin: 20px 0;">
      <button id="load-more-btn" style="display:none;">Load More</button>
    </div>
  </div>
</div>
</body>
</html>
